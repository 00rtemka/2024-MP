our_maze=[]
f=open("maze-for-u.txt")
for i in f.read():
    our_maze.append(i)
f.close()
print(our_maze)


list_to_visit=[]
x,y,x_key,y_key=0,0,0,0

def is_exit(x,y,maze):
    return (x==0)and(y==3)

def add_to_visit_list(list_of_neighbours,list_to_visit):
    return list_to_visit.extend(list_of_neighbours)

def is_in_boundaries(x,y,maze):
    return x<len(maze)-1 and x>=0 and y<len(maze)-1 and y>=0

def is_empty(x,y,maze):
    return maze[x][y]==' '

def is_available(x,y,d,maze):
    x_new=x+d[0]
    y_new=y+d[1]
    return is_in_boundaries(x_new,y_new,maze=our_maze) and is_empty(x_new,y_new,maze=our_maze)

def neighbours_list(x,y, maze=our_maze): #клетки, которые можно посетить
    directions = ((-1,0),(1,0),(0,-1),(0,1))
    neighbours=[]
    for d in directions:
        if is_available(x, y, d, maze):
           neighbours.append((x + d[0], y + d[1]))
    return neighbours
            
def choose_cell_to_visit(list_to_visit):
    return list_to_visit.pop(-1)

def set_item(x,y,maze):
    from numpy import random
    x=random.randint(100,len(maze))
    y=random.randint(100,len(maze))
    if is_empty(x,y,maze)==False:
        x+=1
        y+=1
    return x,y

def is_key(x,y,maze):
    return (x==x_key)and(y==y_key)
    

set_item(x,y,our_maze)
set_item(x_key,y_key,our_maze)
print(x,y,x_key,y_key)
while not is_exit(x,y,maze=our_maze):
    add_to_visit_list(neighbours_list(x,y),list_to_visit)
    x,y=choose_cell_to_visit(list_to_visit)
print(list_to_visit)  
